#!/usr/bin/env python3

# this should not be imported
assert __name__ == '__main__'

# assure we are in the right directory, so we find our relative imports
import os
os.chdir(os.path.dirname(__file__))

# library imports
from email.parser import BytesParser as MailParser
from sys import stdin, exit
import atexit
from logging import shutdown as logging_shutdown

# relative imports
import mailer
import mysqltable
import wikicrawl
import conf
import my_logging

message = None
real_sender = None
real_recipient = None

def mailstr():
	return """##################################################
SMTP From: %s
SMTP TO:   %s
##################################################
%s
##################################################""" % (real_sender, real_recipient, message.as_string())

def fail():
	logger.critical(mailstr())
	exit(conf.exit_fail_code)

# setup logging
atexit.register(logging_shutdown)
logger = my_logging.getLogger(__name__)

logger.debug("Starting mail handling as user %d in group %d"%(os.geteuid(),os.getgid()))

# these may be None, if we are not called by qmail
real_sender = os.getenv("SENDER")
real_recipient = os.getenv("RECIPIENT")

# read message from stdin
try:
	message = MailParser().parse(stdin.buffer)
except Exception as e:
	logger.critical("Could not read mail from stdin",exc_info=True,stack_info=True)
	fail()

logger.debug("Processing mail:\n%s"%mailstr())

lists = []
direct_users = []
try:
	# get mailing list addresses in To and Cc fields
	lists = mailer.get_lists(message)
	logger.debug("Destination mailing lists: %s" % str(list(lists)))
	# get people in To and Cc fields
	direct_users = mailer.get_users(message)
	logger.debug("Direct destination users: %s" % str(list(lists)))
except Exception as e:
	logger.error("Error when analysing destinations in this mail:\n%s"%mailstr(),exc_info=True,stack_info=True)
	# don't exit, still try to send it to the other users

# crawl the wiki to get the destination people
lists_to_users = dict()
try:
	for l in lists:
		lists_to_users[l] = wikicrawl.get_users(l)
except Exception as e:
	logger.error("Error when getting users for list %s from the wiki for this mail:\n%s"%(l,mailstr()),exc_info=True,stack_info=True)

# lookup mail addresses for the destination users
direct_mails = []
lists_to_mails = dict()
try:
	mailTable = mysqltable.MailTable()
	direct_mails = list(map(mailTable.get_mail, users))
	for l,usr in lists_to_users.items():
		lists_to_mails[l] = list(map(mailTable.get_mail, users))
except Exception as e:
	logger.error("Could not lookup email addresses in wiki database for this mail:\n%s"%mailstr(),exc_info=True,stack_info=True)

explicit_mails = mailer.get_mail_destination_addresses(message)
candidate_destinations = set(direct_mails)
for mails in lists_to_mails.values():
	candidate_destinations |= mails
try:
	# maybe an address could not be found for everybody
	candidate_destinations.remove(None)
except KeyError:
	pass

if len(candidate_destinations) == 0:
	logger.info("Mail has no valid destinations")
	exit(conf.exit_fail_code)

def _invert_dict(d):
	ret = dict()
	for k,vl in d.items():
		for v in vl:
			ret.setdefault(v,[]).append(k)
	return ret

mails_to_lists = _invert_dict(lists_to_mails)

actual_destinations = []
for dst in candidate_destinations:
	if dst in explicit_mails:
		# user was also directly addressed, outside of our system
		pass
	elif dst in direct_mails:
		# user was addressed by xxx-user-name...
		if real_recipient == dst:
			actual_destinations.append(dst)
		else:
			# we will be or have been called another time for this mail
			pass
	else:
		# user was addressed by one or more mailing list(s)
		users_lists = sorted(mails_to_lists.get(dst,[]))
		if len(users_lists) == 0:
			# it's a bug if this happens
			logger.critical("Destination %s was in the destination candidates but seems not addressed by this mail:\n%s"%(dst,mailstr()))
			continue
		if real_recipient == users_lists[0]:
			# because users_lists is sorted and we compare only to the first element
			# the mail will only be sent to the user once
			actual_destinations.append(dst)
		else:
			# we will be or have been called another time for this mail
			pass

# for the unsubscribe button
try:
	mailer.add_listinfo(message)
except Exception as e:
	logger.error("failed to add listinfo for this mail\n%s"%mailstr(),exc_info=True,stack_info=True)

try:
	mailer.send_mail(message, actual_destinations)
except Exception as e:
	logger.critical("Failed to send mail.")
	fail()

logger.debug("mail sent.")
exit(0)
